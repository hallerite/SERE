domain: assembly
requirements: [":strips", ":typing"]   # engine can toggle; spec stays superset

# ---------- Types ----------
types:
  - name: robot
  - name: location
  - name: object
  - name: container
    parent: object
  - name: tool
    parent: object
  - name: part
    parent: object
  - name: assembly
    parent: object
  - name: machine
    parent: object
  - name: number

# ---------- Predicates ----------
predicates:
  # spatial / kinematic
  - name: at
    args: [{name: r, type: robot}, {name: l, type: location}]
    nl: "{r} is at {l}"

  - name: obj-at
    args: [{name: o, type: object}, {name: l, type: location}]
    nl: "{o} is at {l}"

  - name: co-located
    args: [{name: x, type: object}, {name: y, type: object}]
    nl: "{x} and {y} are at the same location"

  - name: adjacent
    args: [{name: l1, type: location}, {name: l2, type: location}]
    static: true
    nl: "{l1} is adjacent to {l2}"

  # grasping / hand state
  - name: holding
    args: [{name: r, type: robot}, {name: o, type: object}]
    nl: "{r} is holding {o}"

  - name: clear-hand
    args: [{name: r, type: robot}]
    nl: "{r} has a free hand"

  # containers & openness
  - name: in
    args: [{name: o, type: object}, {name: c, type: container}]
    nl: "{o} is in {c}"

  - name: open
    args: [{name: c, type: container}]
    nl: "{c} is open"

  # tools & equipment state
  - name: equipped
    args: [{name: r, type: robot}, {name: t, type: tool}]
    nl: "{r} has {t} equipped"

  - name: tool-for
    args: [{name: t, type: tool}, {name: op, type: object}]
    static: true
    nl: "{t} is suitable for {op}"

  # assembly relations
  - name: aligned
    args: [{name: p, type: part}, {name: a, type: assembly}]
    nl: "{p} is aligned with {a}"

  - name: installed
    args: [{name: p, type: part}, {name: a, type: assembly}]
    nl: "{p} is installed on {a}"

  - name: fastened
    args: [{name: p, type: part}, {name: a, type: assembly}]
    nl: "{p} is fastened to {a}"

  - name: damaged
    args: [{name: o, type: object}]
    nl: "{o} is damaged"

  # infrastructure / facilities
  - name: has-charger
    args: [{name: l, type: location}]
    static: true
    nl: "{l} has a charging station"

  - name: has-fixture
    args: [{name: l, type: location}]
    static: true
    nl: "{l} has a vise/fixture"

  # machines
  - name: powered
    args: [{name: m, type: machine}]
    nl: "{m} is powered"

  # quality of outcome
  - name: defective
    args: [{name: a, type: assembly}]
    nl: "{a} is defective"

  - name: needs-rework
    args: [{name: a, type: assembly}]
    nl: "{a} needs rework"

# ---------- Fluents (numeric state) ----------
fluents:

  - name: battery-cap
    args: [{name: r, type: robot}]
    nl: "Battery capacity of {r}"

  - name: energy
    args: [{name: r, type: robot}]
    nl: "Energy of {r}"

  - name: torque
    args: [{name: t, type: tool}]
    nl: "Torque setting on {t}"

  - name: quality
    args: [{name: a, type: assembly}]
    nl: "Quality score of {a}"

# ---------- Actions ----------
actions:

  - name: wait
    params: [{n: number}]
    pre: []
    add: []
    del: []
    duration_var: "n"
    duration_unit: 1.0
    nl: "Wait for {n} ticks"
    messages:
      - "Waited {n} ticks."

  # movement / navigation
  - name: move
    params: [{r: robot}, {from: location}, {to: location}]
    pre:
      - "(at ?r ?from)"
      - "(adjacent ?from ?to)"
      - "(>= (energy ?r) 1)"
      - "(distinct ?from ?to)"

    add: ["(at ?r ?to)"]
    del: ["(at ?r ?from)"]
    num_eff: ["(decrease (energy ?r) 1)"]
    duration: 1.0
    messages:
      - "{r} moved from {from} to {to}. Energy is now (energy ?r)."

  # container access (crates, bins, drawers)
  - name: open
    params: [{r: robot}, {c: container}]
    pre: ["(co-located ?r ?c)", "(not (open ?c))"]
    add: ["(open ?c)"]
    num_eff: ["(decrease (energy ?r) 0.2)"]
    duration: 0.3
    messages:
      - "{c} is now open."

  - name: close
    params: [{r: robot}, {c: container}]
    pre: ["(co-located ?r ?c)", "(open ?c)"]
    del: ["(open ?c)"]
    num_eff: ["(decrease (energy ?r) 0.2)"]
    duration: 0.3
    messages:
      - "{c} is now closed."

  # picking & placing
  - name: pick-up
    params: [{r: robot}, {o: object}]
    pre: ["(co-located ?r ?o)", "(clear-hand ?r)"]
    add: ["(holding ?r ?o)"]
    del: ["(obj-at ?o ?l)", "(clear-hand ?r)"]
    num_eff: ["(decrease (energy ?r) 0.3)"]
    duration: 0.5
    messages:
      - "Picked up {o}."

  - name: put-down
    params: [{r: robot}, {o: object}]
    pre: ["(holding ?r ?o)"]
    add: ["(obj-at ?o ?l)", "(clear-hand ?r)"]
    del: ["(holding ?r ?o)"]
    num_eff: ["(decrease (energy ?r) 0.3)"]
    duration: 0.5
    messages:
      - "Placed {o} on the bench at your current location."


  # storage
  - name: put-in
    params: [{r: robot}, {o: object}, {c: container}]
    pre: ["(co-located ?r ?c)", "(holding ?r ?o)", "(open ?c)"]
    add: ["(in ?o ?c)", "(clear-hand ?r)"]
    del: ["(holding ?r ?o)", "(obj-at ?o ?l)"]
    num_eff: ["(decrease (energy ?r) 0.3)"]
    duration: 0.5
    messages:
      - "{o} is now in {c}."


  - name: take-out
    params: [{r: robot}, {o: object}, {c: container}]
    pre: ["(co-located ?r ?c)", "(in ?o ?c)", "(open ?c)", "(clear-hand ?r)"]
    add: ["(holding ?r ?o)"]
    del: ["(in ?o ?c)", "(clear-hand ?r)"]
    num_eff: ["(decrease (energy ?r) 0.3)"]
    duration: 0.5
    messages:
      - "Took {o} out of {c}."


  # tool management
  - name: equip-tool
    params: [{r: robot}, {t: tool}]
    pre: ["(holding ?r ?t)"]
    add: ["(equipped ?r ?t)", "(clear-hand ?r)"]
    del: ["(holding ?r ?t)"]
    num_eff: ["(decrease (energy ?r) 0.2)"]
    duration: 0.4
    messages:
      - "{t} equipped."


  - name: unequip-tool
    params: [{r: robot}, {t: tool}]
    pre: ["(equipped ?r ?t)", "(clear-hand ?r)"]
    add: ["(holding ?r ?t)"]
    del: ["(equipped ?r ?t)", "(clear-hand ?r)"]
    num_eff: ["(decrease (energy ?r) 0.2)"]
    duration: 0.4
    messages:
      - "{t} unequipped."


  # preparation & alignment
  - name: align
    params: [{r: robot}, {p: part}, {a: assembly}]
    pre: ["(co-located ?r ?p)", "(co-located ?r ?a)"]
    add: ["(aligned ?p ?a)"]
    num_eff: ["(decrease (energy ?r) 0.5)"]
    duration: 1.0
    messages:
      - "{p} aligned with {a}."


  # assembly (fasten/attach) with conditionals
  - name: fasten
    params: [{r: robot}, {p: part}, {a: assembly}, {t: tool}]
    pre: ["(equipped ?r ?t)", "(tool-for ?t ?a)", "(aligned ?p ?a)", "(co-located ?r ?p)", "(co-located ?r ?a)"]
    add: ["(fastened ?p ?a)", "(installed ?p ?a)"]
    num_eff: ["(decrease (energy ?r) 1.0)"]
    duration: 2.0
    messages:
      - "Fastened {p} to {a}."
    cond:
      - when: ["(damaged ?p)"]
        delete: ["(installed ?p ?a)"]
    outcomes:
      - name: "hard_defect"
        p: 0.10
        add: ["(defective ?a)"]
        num_eff: ["(assign (quality ?a) 0.20)"]
        messages:
          - "QC: Hard defect on ?a detected. Disassemble and reassemble."
      - name: "soft_defect"
        p: 0.30
        add: ["(needs-rework ?a)"]
        num_eff: ["(assign (quality ?a) 0.65)"]
        messages:
          - "QC: Marginal quality on ?a (rework needed). Consider unfasten → realign → refasten."
      - name: "good"
        p: 0.60
        delete: ["(defective ?a)", "(needs-rework ?a)"]
        num_eff: ["(assign (quality ?a) 0.95)"]
        messages:
          - "QC: ?a passed. Quality=good."


  # optional: torque setting influences nothing structural but gives room for curricula
  - name: set-torque
    params: [{r: robot}, {t: tool}, {lvl: object}]
    pre: ["(equipped ?r ?t)"]
    add: []
    num_eff: ["(decrease (energy ?r) 0.1)"]
    duration: 0.2
    messages:
      - "Torque on {t} set to {lvl}."


  # disassembly (unfasten & detach) – yields the part in-hand
  - name: unfasten
    params: [{r: robot}, {p: part}, {a: assembly}, {t: tool}]
    pre: ["(equipped ?r ?t)", "(tool-for ?t ?a)", "(fastened ?p ?a)", "(co-located ?r ?p)", "(co-located ?r ?a)", "(clear-hand ?r)"]
    add: ["(holding ?r ?p)"]
    del: ["(fastened ?p ?a)", "(installed ?p ?a)", "(clear-hand ?r)"]
    num_eff: ["(decrease (energy ?r) 1.0)"]
    duration: 2.0
    messages:
      - "Unfastened {p} from {a}; now holding {p}."


  # place subassemblies back onto bench (explicit convenience primitive)
  - name: place-on-bench
    params: [{r: robot}, {o: object}]
    pre: ["(holding ?r ?o)"]
    add: ["(obj-at ?o ?l)", "(clear-hand ?r)"]
    del: ["(holding ?r ?o)"]
    num_eff: ["(decrease (energy ?r) 0.3)"]
    duration: 0.5
    messages:
      - "Placed {o} on the bench."


  # machines (e.g., power screwdriver station) – optional affordance
  - name: power-on
    params: [{r: robot}, {m: machine}]
    pre: ["(co-located ?r ?m)", "(not (powered ?m))"]
    add: ["(powered ?m)"]
    num_eff: ["(decrease (energy ?r) 0.2)"]
    duration: 0.5
    messages:
      - "{m} is now powered."


  # resource maintenance
  - name: recharge
    params: [{r: robot}, {l: location}]
    pre: ["(at ?r ?l)", "(has-charger ?l)"]
    add: []
    num_eff: ["(increase (energy ?r) 5)"]
    duration: 2.0
    messages:
      - "{r} recharged at {l}. Energy is now (energy ?r)."

  - name: qc-check
    params: [{r: robot}, {a: assembly}]
    pre: ["(co-located ?r ?a)"]
    add: []
    num_eff: []
    duration: 0.2
    messages:
      - "QC Report for ?a — quality=(quality ?a), flags: (defective ?a) (needs-rework ?a)"

  - name: realign
    params: [{r: robot}, {p: part}, {a: assembly}]
    pre: ["(co-located ?r ?p)", "(co-located ?r ?a)"]
    add: ["(aligned ?p ?a)"]
    delete: []
    num_eff: ["(decrease (energy ?r) 0.3)"]
    duration: 0.5
    messages:
      - "Realigned {p} with {a}."
